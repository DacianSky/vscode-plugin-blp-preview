//-----------------------------------------------------------------------------
// Table of byte-to-weight values
const weightTables: Array<number[]> = [];
// Table for (de)compression. Every compression type has 258 entries
weightTables[0] =
    [
        0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00
    ];

// Data for compression type 0x01
weightTables[1] =
    [
        0x54, 0x16, 0x16, 0x0D, 0x0C, 0x08, 0x06, 0x05, 0x06, 0x05, 0x06, 0x03, 0x04, 0x04, 0x03, 0x05,
        0x0E, 0x0B, 0x14, 0x13, 0x13, 0x09, 0x0B, 0x06, 0x05, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02,
        0x0D, 0x07, 0x09, 0x06, 0x06, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02,
        0x09, 0x06, 0x04, 0x04, 0x04, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04,
        0x08, 0x03, 0x04, 0x07, 0x09, 0x05, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02,
        0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
        0x06, 0x0A, 0x08, 0x08, 0x06, 0x07, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x04, 0x02, 0x03, 0x03,
        0x04, 0x03, 0x07, 0x07, 0x09, 0x06, 0x04, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02,
        0x0A, 0x02, 0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x03, 0x05, 0x02, 0x03,
        0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01,
        0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x04, 0x07, 0x09, 0x08, 0x0C, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x03,
        0x04, 0x01, 0x02, 0x04, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
        0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x4B,
        0x00, 0x00
    ];

// Data for compression type 0x02
weightTables[2] =
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00, 0x00, 0x23, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x06, 0x0E, 0x10, 0x04,
        0x06, 0x08, 0x05, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01,
        0x01, 0x04, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01, 0x02, 0x03, 0x03, 0x02,
        0x03, 0x01, 0x03, 0x06, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01,
        0x01, 0x29, 0x07, 0x16, 0x12, 0x40, 0x0A, 0x0A, 0x11, 0x25, 0x01, 0x03, 0x17, 0x10, 0x26, 0x2A,
        0x10, 0x01, 0x23, 0x23, 0x2F, 0x10, 0x06, 0x07, 0x02, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00
    ];

// Data for compression type 0x03
weightTables[3] =
    [
        0xFF, 0x0B, 0x07, 0x05, 0x0B, 0x02, 0x02, 0x02, 0x06, 0x02, 0x02, 0x01, 0x04, 0x02, 0x01, 0x03,
        0x09, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
        0x05, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x02, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
        0x0A, 0x04, 0x02, 0x01, 0x06, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01,
        0x05, 0x02, 0x03, 0x04, 0x03, 0x03, 0x03, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03,
        0x01, 0x03, 0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03, 0x05, 0x01, 0x03, 0x01, 0x03, 0x03,
        0x02, 0x01, 0x04, 0x03, 0x0A, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x02, 0x02, 0x01, 0x0A, 0x02, 0x05, 0x01, 0x01, 0x02, 0x07, 0x02, 0x17, 0x01, 0x05, 0x01, 0x01,
        0x0E, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x06, 0x02, 0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
        0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11,
        0x00, 0x00
    ];

// Data for compression type 0x04
weightTables[4] =
    [
        0xFF, 0xFB, 0x98, 0x9A, 0x84, 0x85, 0x63, 0x64, 0x3E, 0x3E, 0x22, 0x22, 0x13, 0x13, 0x18, 0x17,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00
    ];

// Data for compression type 0x05
weightTables[5] =
    [
        0xFF, 0xF1, 0x9D, 0x9E, 0x9A, 0x9B, 0x9A, 0x97, 0x93, 0x93, 0x8C, 0x8E, 0x86, 0x88, 0x80, 0x82,
        0x7C, 0x7C, 0x72, 0x73, 0x69, 0x6B, 0x5F, 0x60, 0x55, 0x56, 0x4A, 0x4B, 0x40, 0x41, 0x37, 0x37,
        0x2F, 0x2F, 0x27, 0x27, 0x21, 0x21, 0x1B, 0x1C, 0x17, 0x17, 0x13, 0x13, 0x10, 0x10, 0x0D, 0x0D,
        0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x04, 0x19, 0x18,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00
    ];

// Data for compression type 0x06
weightTables[6] =
    [
        0xC3, 0xCB, 0xF5, 0x41, 0xFF, 0x7B, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xBF, 0xCC, 0xF2, 0x40, 0xFD, 0x7C, 0xF7, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7A, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00
    ];

// Data for compression type 0x07
weightTables[7] =
    [
        0xC3, 0xD9, 0xEF, 0x3D, 0xF9, 0x7C, 0xE9, 0x1E, 0xFD, 0xAB, 0xF1, 0x2C, 0xFC, 0x5B, 0xFE, 0x17,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xBD, 0xD9, 0xEC, 0x3D, 0xF5, 0x7D, 0xE8, 0x1D, 0xFB, 0xAE, 0xF0, 0x2C, 0xFB, 0x5C, 0xFF, 0x18,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x70, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00
    ];

// Data for compression type 0x08
weightTables[8] =
    [
        0xBA, 0xC5, 0xDA, 0x33, 0xE3, 0x6D, 0xD8, 0x18, 0xE5, 0x94, 0xDA, 0x23, 0xDF, 0x4A, 0xD1, 0x10,
        0xEE, 0xAF, 0xE4, 0x2C, 0xEA, 0x5A, 0xDE, 0x15, 0xF4, 0x87, 0xE9, 0x21, 0xF6, 0x43, 0xFC, 0x12,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xB0, 0xC7, 0xD8, 0x33, 0xE3, 0x6B, 0xD6, 0x18, 0xE7, 0x95, 0xD8, 0x23, 0xDB, 0x49, 0xD0, 0x11,
        0xE9, 0xB2, 0xE2, 0x2B, 0xE8, 0x5C, 0xDD, 0x15, 0xF1, 0x87, 0xE7, 0x20, 0xF7, 0x44, 0xFF, 0x13,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x5F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00
    ];

function printByte(value: number) {
    return ('00000000' + value.toString(2)).slice(-8);
}

class TInputStream {
    private pbInBuffer: Uint8Array;
    private bitBuffer: number;
    private pos: number;
    public bitCount: number;

    constructor(pvInBuffer: ArrayBuffer) {
        this.pbInBuffer = new Uint8Array(pvInBuffer);
        this.pos = 0;
        this.bitBuffer = 0;
        this.bitCount = 0;
    }

    isEnd(): boolean {
        return this.pos >= this.pbInBuffer.length && this.bitCount < 7;
    }

    // Gets 7 bits from the stream. DOES NOT remove the bits from input stream
    peek7Bits(): number {
        let dwReloadByte = 0;

        // If there is not enough bits to get the value,
        // we have to add 8 more bits from the input buffer
        if (this.bitCount < 7) {
            dwReloadByte = this.pbInBuffer[this.pos++];
            this.bitBuffer |= dwReloadByte << this.bitCount;
            this.bitCount += 8;
        }

        // Return the first available 7 bits. DO NOT remove them from the input stream
        return (this.bitBuffer & 0x7f);
    }

    // Gets one bit from input stream
    get1Bit(): number {
        let oneBit = 0;

        // Ensure that the input stream is reloaded, if there are no bits left
        if (this.bitCount === 0) {
            // Refill the bit buffer
            this.bitBuffer = this.pbInBuffer[this.pos++];
            this.bitCount = 8;
        }

        // Copy the bit from bit buffer to the variable
        oneBit = (this.bitBuffer & 0x01);
        this.bitBuffer >>= 1;
        this.bitCount--;

        return oneBit;
    }

    // Gets the whole byte from the input stream.
    get8Bits(): number {
        let dwReloadByte = 0;
        let dwOneByte = 0;

        // If there is not enough bits to get the value,
        // we have to add 8 more bits from the input buffer
        if (this.bitCount < 8) {
            dwReloadByte = this.pbInBuffer[this.pos++];
            this.bitBuffer |= dwReloadByte << this.bitCount;
            this.bitCount += 8;
        }

        // Return the lowest 8 bits
        dwOneByte = (this.bitBuffer & 0xff);
        this.bitBuffer >>= 8;
        this.bitCount -= 8;
        return dwOneByte;
    }

    skipBits(dwBitsToSkip: number): void {
        let dwReloadByte = 0;

        // If there is not enough bits in the buffer,
        // we have to add 8 more bits from the input buffer
        if (this.bitCount < dwBitsToSkip) {
            dwReloadByte = this.pbInBuffer[this.pos++];
            this.bitBuffer |= dwReloadByte << this.bitCount;
            this.bitCount += 8;
        }

        // Skip the remaining bits
        this.bitBuffer >>= dwBitsToSkip;
        this.bitCount -= dwBitsToSkip;
    }
}

class TOutputStream {
    private pbOutBuffer: number[] = [];
    private bitBuffer = 0;
    private bitCount = 0;
    private pos = 0;

    constructor(private cbOutLength: number) {
    }

    public get data() {
        return Uint8Array.from(this.pbOutBuffer).buffer;
    }

    putBits(dwValue: number, nBitCount: number): void {
        this.bitBuffer |= (dwValue << this.bitCount);
        this.bitCount += nBitCount;

        // Flush completed bytes
        while (this.bitCount >= 8) {
            if (this.pos < this.cbOutLength) {
                this.pbOutBuffer[this.pos++] = this.bitBuffer & 0xff;
            }

            this.bitBuffer >>= 8;
            this.bitCount -= 8;
        }
    }

    flush(): void {
        while (this.bitCount !== 0) {
            if (this.pos < this.cbOutLength) {
                this.pbOutBuffer[this.pos++] = this.bitBuffer & 0xff;
            }

            this.bitBuffer >>= 8;
            this.bitCount -= this.bitCount > 8 ? 8 : this.bitCount;
        }
    }
}

interface ITtreeNode {
    pPrev: ITtreeNode | null;
    pNext: ITtreeNode | null;
}

// Huffmann tree item
class THTreeItem implements ITtreeNode {
    decompressedValue: number = 0;
    weight: number = 0;

    pPrev: THTreeItem | null = null;
    pNext: THTreeItem | null = null;

    pParent: THTreeItem | null = null;
    pChildLo: THTreeItem | null = null;

    removeItem(): void {
        if (this.pNext !== null) {
            this.pPrev!.pNext = this.pNext;
            this.pNext.pPrev = this.pPrev;
            this.pNext = null;
            this.pPrev = null;
        }
    }
}

// 用于快速在哈夫曼树中导航的结构体。
// 允许在压缩流中跳过最多7位，因此可以更快地解压缩。
// 有时它甚至可以直接获取解压缩的字节。

interface TQuickLink {
    validValue: number;            // 如果大于THuffmannTree::MinValidValue，则该条目为有效条目。
    validBits: number;             // 该条目链接中有效的比特数。
    pItem: THTreeItem | null;      // 指向Huffmann树中的项目的指针。该项目的类型为THTreeItem，或者为null。
    decompressedValue: number;     // 直接解压缩时的值。
};

enum TInsertPoint {
    insertAfter = 1,
    insertBefore = 2
};

const HUFF_ITEM_COUNT = 0x203;
const LINK_ITEM_COUNT = 0x80;         // Maximum number of quick-link items

class THuffmanTree implements ITtreeNode {
    pFirst: THTreeItem;
    pLast: THTreeItem;

    LIST_HEAD() {
        return this as unknown as THTreeItem;
    }

    get pPrev() {
        return this.pLast;
    }

    set pPrev(item: THTreeItem) {
        this.pLast = item;
    }

    get pNext() {
        return this.pFirst;
    }

    set pNext(item: THTreeItem) {
        this.pFirst = item;
    }

    toString() {
        return 'LIST_HEAD';
    }

    constructor() {
        this.pFirst = this.pLast = this.LIST_HEAD();
    }

    itemsByByte: THTreeItem[] = new Array(0x102);
    quickLinks: TQuickLink[] = new Array(LINK_ITEM_COUNT).fill(0).map(() => ({
        validValue: 0,
        validBits: 0,
        pItem: null,
        decompressedValue: 0,
    }));

    // A minimum value of TQDecompress::ValidValue to be considered valid
    minValidValue: number = 1;
    // 1 if compression type 0
    bIsCmp0: boolean = false;

    linkTwoItems(pItem1: THTreeItem, pItem2: THTreeItem) {
        pItem2.pNext = pItem1.pNext;
        pItem2.pPrev = pItem1.pNext!.pPrev;
        pItem1.pNext!.pPrev = pItem2;
        pItem1.pNext = pItem2;
    }

    insertItem(pNewItem: THTreeItem, insertPoint: TInsertPoint, pInsertPoint: THTreeItem | null = null) {
        // Remove the item from the tree
        pNewItem.removeItem();

        if (pInsertPoint === null) {
            pInsertPoint = this.LIST_HEAD();
        }

        switch (insertPoint) {
            case TInsertPoint.insertAfter:
                this.linkTwoItems(pInsertPoint, pNewItem);
                return;

            case TInsertPoint.insertBefore:
                pNewItem.pNext = pInsertPoint;             // Set next item (or pointer to pointer to first item)
                pNewItem.pPrev = pInsertPoint.pPrev;      // Set prev item (or last item in the tree)
                pInsertPoint.pPrev!.pNext = pNewItem;
                pInsertPoint.pPrev = pNewItem;             // Set the next/last item
                return;
        }
    }

    findHigherOrEqualItem(pItem: THTreeItem | null, weight: number) {
        // Parse all existing items
        if (pItem !== null) {
            while (pItem !== this.LIST_HEAD()) {
                if (pItem.weight >= weight) {
                    return pItem;
                }

                pItem = pItem.pPrev!;
            }
        }

        // If not found, we just get the first item
        return this.LIST_HEAD();
    }

    createNewItem(decompressedValue: number, weight: number, insertPoint: TInsertPoint) {
        // Allocate new item from the item pool
        const pNewItem = new THTreeItem();

        // Insert this item to the top of the tree
        this.insertItem(pNewItem, insertPoint, null);

        // Fill the rest of the item
        pNewItem.decompressedValue = decompressedValue;
        pNewItem.weight = weight;
        pNewItem.pParent = null;
        pNewItem.pChildLo = null;
        return pNewItem;
    }

    fixupItemPosByWeight(pNewItem: THTreeItem, maxWeight: number) {
        if (pNewItem.weight < maxWeight) {
            // Find an item that has higher weight than this one
            const pHigherItem = this.findHigherOrEqualItem(this.pLast, pNewItem.weight);

            // Remove the item and put it to the new position
            pNewItem.removeItem();
            if (!pHigherItem.pNext) {
                let p: THTreeItem | null = this.pFirst;
                while (p && p !== this.pLast) {
                    p = p.pNext;
                }
            }
            this.linkTwoItems(pHigherItem, pNewItem);
        }
        else {
            maxWeight = pNewItem.weight;
        }

        // Return the (updated) maximum weight
        return maxWeight;
    }

    buildTree(compressionType: number) {
        let pNewItem: THTreeItem;
        let pChildLo: THTreeItem;
        let pChildHi: THTreeItem;
        let weightTable: number[];
        let maxWeight: number;                     // [ESP+10] - The greatest character found in table

        // Clear all pointers in HTree item array
        maxWeight = 0;

        // Ensure that the compression type is in range
        if ((compressionType & 0x0F) > 0x08) {
            return false;
        }
        weightTable = weightTables[compressionType & 0x0F];

        // Build the linear list of entries that is sorted by byte weight
        for (let i = 0; i < 0x100; i++) {
            // Skip all the bytes which are zero.
            if (weightTable[i] !== 0) {
                // Create new tree item
                this.itemsByByte[i] = pNewItem = this.createNewItem(i, weightTable[i], TInsertPoint.insertAfter);

                // We need to put the item to the right place in the list
                maxWeight = this.fixupItemPosByWeight(pNewItem, maxWeight);
            }
        }

        // Insert termination entries at the end of the list
        this.itemsByByte[0x100] = this.createNewItem(0x100, 1, TInsertPoint.insertBefore);
        this.itemsByByte[0x101] = this.createNewItem(0x101, 1, TInsertPoint.insertBefore);

        // Now we need to build the tree. We start at the last entry
        // and go backwards to the first one
        pChildLo = this.pLast;

        // Work as long as both children are valid
        // pChildHi is child with higher weight, pChildLo is the one with lower weight
        while (pChildLo !== this.LIST_HEAD()) {
            // Also get and verify the higher-weight child
            pChildHi = pChildLo.pPrev!;
            if (pChildHi === this.LIST_HEAD()) {
                break;
            }

            // Create new parent item for the children
            pNewItem = this.createNewItem(0, pChildHi.weight + pChildLo.weight, TInsertPoint.insertAfter);

            // Link both child items to their new parent
            pChildLo.pParent = pNewItem;
            pChildHi.pParent = pNewItem;
            pNewItem.pChildLo = pChildLo;

            // Fixup the item's position by its weight
            maxWeight = this.fixupItemPosByWeight(pNewItem, maxWeight);

            // Get the previous lower-weight child
            pChildLo = pChildHi.pPrev!;
        }

        // Initialize the MinValidValue to 1, which invalidates all quick-link items
        this.minValidValue = 1;
        return true;
    }

    incWeightsAndRebalance(pItem: THTreeItem | null) {
        let pHigherItem: THTreeItem;           // A previous item with greater or equal weight
        let pChildHi: THTreeItem;              // The higher-weight child
        let pChildLo: THTreeItem;              // The lower-weight child
        let pParent: THTreeItem;

        // Climb up the tree and increment weight of each tree item
        for (; pItem !== null; pItem = pItem.pParent) {
            // Increment the item's weight
            pItem.weight++;

            // Find a previous item with equal or greater weight, which is not equal to this item
            pHigherItem = this.findHigherOrEqualItem(pItem.pPrev, pItem.weight);
            pChildHi = pHigherItem.pNext!;

            // If the item is not equal to the tree item, we need to rebalance the tree
            if (pChildHi !== pItem) {
                // Move the previous item to the RIGHT from the given item
                pChildHi.removeItem();
                this.linkTwoItems(pItem, pChildHi);

                // Move the given item AFTER the greater-weight tree item
                pItem.removeItem();
                this.linkTwoItems(pHigherItem, pItem);

                // We need to maintain the tree so that pChildHi->Weight is >= pChildLo->Weight.
                // Rebalance the tree accordingly.
                pChildLo = pChildHi.pParent!.pChildLo!;
                pParent = pItem.pParent!;
                if (pParent.pChildLo === pItem) {
                    pParent.pChildLo = pChildHi;
                }
                if (pChildLo === pChildHi) {
                    pChildHi.pParent!.pChildLo = pItem;
                }
                pParent = pItem.pParent!;
                pItem.pParent = pChildHi.pParent;
                pChildHi.pParent = pParent;

                // Increment the global valid value. This invalidates all quick-link items.
                this.minValidValue++;
            }
        }
    }

    insertNewBranchAndRebalance(value1: number, value2: number) {
        let pLastItem: THTreeItem = this.pLast;
        let pChildHi: THTreeItem;
        let pChildLo: THTreeItem;

        // Create higher-weight child
        pChildHi = this.createNewItem(value1, pLastItem.weight, TInsertPoint.insertBefore);
        pChildHi.pParent = pLastItem;
        this.itemsByByte[value1] = pChildHi;

        // Create lower-weight child
        pChildLo = this.createNewItem(value2, 0, TInsertPoint.insertBefore);
        pChildLo.pParent = pLastItem;
        pLastItem.pChildLo = pChildLo;
        this.itemsByByte[value2] = pChildLo;

        this.incWeightsAndRebalance(pChildLo);
    }

    encodeOneByte(os: TOutputStream, pItem: THTreeItem) {
        let pParent = pItem.pParent;
        let bitBuffer = 0;
        let bitCount = 0;

        // Put 1's as long as there is parent
        while (pParent !== null) {
            // Fill the bit buffer
            bitBuffer = (bitBuffer << 1) | ((pParent.pChildLo !== pItem) ? 1 : 0);
            bitCount++;

            // Move to the parent
            pItem = pParent;
            pParent = pParent.pParent;
        }

        // Write the bits to the output stream
        os.putBits(bitBuffer, bitCount);
    }

    decodeOneByte(is: TInputStream) {
        let pItemLink: THTreeItem | null = null;
        let pItem: THTreeItem;
        let itemLinkIndex: number;
        let bitCount = 0;

        // Check for the end of the input stream
        if (is.isEnd()) {
            throw new Error('is is end');
        }

        // Get the eventual quick-link index
        itemLinkIndex = is.peek7Bits();

        // Is the quick-link item valid?
        if (this.quickLinks[itemLinkIndex].validValue > this.minValidValue) {
            // If that item needs less than 7 bits, we can get decompressed value directly
            if (this.quickLinks[itemLinkIndex].validBits <= 7) {
                is.skipBits(this.quickLinks[itemLinkIndex].validBits);
                return this.quickLinks[itemLinkIndex].decompressedValue;
            }

            // Otherwise we cannot get decompressed value directly
            // but we can skip 7 levels of tree parsing
            pItem = this.quickLinks[itemLinkIndex].pItem!;
            is.skipBits(7);
        }
        else {
            // Just a sanity check
            if (this.pFirst === this.LIST_HEAD()) {
                throw new Error('pFirst is head');
            }

            // We don't have the quick-link item, we need to parse the tree from its root
            pItem = this.pFirst;
        }

        // Step down the tree until we find a terminal item
        while (pItem.pChildLo !== null) {
            // If the next bit in the compressed stream is set, we get the higher-weight
            // child. Otherwise, get the lower-weight child.
            pItem = is.get1Bit() ? pItem.pChildLo.pPrev! : pItem.pChildLo;
            bitCount++;

            // If the number of loaded bits reached 7,
            // remember the current item for storing into quick-link item array
            if (bitCount === 7) {
                pItemLink = pItem;
            }
        }

        // If we didn't get the item from the quick-link array,
        // set the entry in it
        if (this.quickLinks[itemLinkIndex].validValue < this.minValidValue) {
            // If the current compressed byte was more than 7 bits,
            // set a quick-link item with pointer to tree item
            if (bitCount > 7) {
                this.quickLinks[itemLinkIndex].validValue = this.minValidValue;
                this.quickLinks[itemLinkIndex].validBits = bitCount;
                this.quickLinks[itemLinkIndex].pItem = pItemLink;
            }
            else {
                // Limit the quick-decompress item to lower amount of bits
                // Coverity fix 84457: (x >> 32) has undefined behavior
                itemLinkIndex = (bitCount !== 0) ? itemLinkIndex & (0xFFFFFFFF >> (32 - bitCount)) : 0;
                while (itemLinkIndex < LINK_ITEM_COUNT) {
                    // Fill the quick-decompress item
                    this.quickLinks[itemLinkIndex].validValue = this.minValidValue;
                    this.quickLinks[itemLinkIndex].validBits = bitCount;
                    this.quickLinks[itemLinkIndex].decompressedValue = pItem.decompressedValue;

                    // Increment the index
                    itemLinkIndex += (1 << bitCount);
                }
            }
        }

        // Return the decompressed value from the found item
        return pItem.decompressedValue;
    }

    compress(os: TOutputStream, pvInBuffer: Uint8Array, compressionType: number) {
        let pos = 0;
        if (!this.buildTree(compressionType)) {
            return null;
        }
        this.bIsCmp0 = (compressionType === 0);

        // Store the compression type into output buffer
        os.putBits(compressionType, 8);

        // Process the entire input buffer
        while (pos < pvInBuffer.length) {
            // Get the (next) byte from the input buffer
            let inputByte = pvInBuffer[pos++];

            // Do we have an item for such input value?
            if (this.itemsByByte[inputByte] === null) {
                // Encode the relationship
                this.encodeOneByte(os, this.itemsByByte[0x101]);

                // Store the loaded byte into output stream
                os.putBits(inputByte, 8);

                this.insertNewBranchAndRebalance(this.pLast.decompressedValue, inputByte);

                if (this.bIsCmp0) {
                    this.incWeightsAndRebalance(this.itemsByByte[inputByte]);
                    continue;
                }

                this.incWeightsAndRebalance(this.itemsByByte[inputByte]);
            }
            else {
                this.encodeOneByte(os, this.itemsByByte[inputByte]);
            }

            if (this.bIsCmp0) {
                this.incWeightsAndRebalance(this.itemsByByte[inputByte]);
            }
        }

        // Put the termination mark to the compressed stream
        this.encodeOneByte(os, this.itemsByByte[0x100]);

        // Flush the remaining bits
        os.flush();
        return os.data;
    }

    decompress(is: TInputStream) {
        const data: number[] = [];
        let decompressedValue = 0;

        // Get the compression type from the input stream
        const compressionType = is.get8Bits();
        const bIsCmp0 = (compressionType === 0) ? 1 : 0;

        // Build the Huffman tree
        if (!this.buildTree(compressionType)) {
            throw new Error('build tree failed');
        }

        // Process the entire input buffer until end of the stream
        while ((decompressedValue = this.decodeOneByte(is)) !== 0x100) {
            // Did an error occur?
            if (decompressedValue === 0x1FF) {         // An error occurred
                throw new Error('decode one byte failed');
            }

            // Huffman tree needs to be modified
            if (decompressedValue === 0x101) {
                // The decompressed byte is stored in the next 8 bits
                decompressedValue = is.get8Bits();

                this.insertNewBranchAndRebalance(this.pLast.decompressedValue, decompressedValue);

                if (bIsCmp0 === 0) {
                    this.incWeightsAndRebalance(this.itemsByByte[decompressedValue]);
                }
            }

            // A byte successfully decoded - store it in the output stream
            // *pbOutBuffer++ = (unsigned char)DecompressedValue;
            data.push(decompressedValue);

            if (bIsCmp0) {
                this.incWeightsAndRebalance(this.itemsByByte[decompressedValue]);
            }
        }

        return Uint8Array.from(data);
    }
}

export default function decodeHuffman(bytes: Uint8Array): Uint8Array {
    const tree = new THuffmanTree();
    return tree.decompress(new TInputStream(bytes));
}
