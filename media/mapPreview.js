(()=>{"use strict";var t={};(t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})})(t);var e="undefined"!=typeof Float32Array?Float32Array:Array;function i(){var t=new e(3);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function n(t){var e=t[0],i=t[1],n=t[2];return Math.hypot(e,i,n)}function r(t,i,n){var r=new e(3);return r[0]=t,r[1]=i,r[2]=n,r}function s(t,e,i,n){return t[0]=e,t[1]=i,t[2]=n,t}function a(t,e,i){return t[0]=e[0]+i[0],t[1]=e[1]+i[1],t[2]=e[2]+i[2],t}function o(t,e,i){return t[0]=e[0]*i,t[1]=e[1]*i,t[2]=e[2]*i,t}function h(t,e){var i=e[0],n=e[1],r=e[2],s=i*i+n*n+r*r;return s>0&&(s=1/Math.sqrt(s)),t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t}function l(t,e,i){var n=e[0],r=e[1],s=e[2],a=i[3]*n+i[7]*r+i[11]*s+i[15];return a=a||1,t[0]=(i[0]*n+i[4]*r+i[8]*s+i[12])/a,t[1]=(i[1]*n+i[5]*r+i[9]*s+i[13])/a,t[2]=(i[2]*n+i[6]*r+i[10]*s+i[14])/a,t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});function u(){var t=new e(4);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function c(){var t=new e(4);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function d(t,e,i){i*=.5;var n=Math.sin(i);return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=Math.cos(i),t}i(),u();var f;i(),r(1,0,0),r(0,1,0),c(),c(),f=new e(9),e!=Float32Array&&(f[1]=0,f[2]=0,f[3]=0,f[5]=0,f[6]=0,f[7]=0),f[0]=1,f[4]=1,f[8]=1;const A=i(),m=i(),v=c(),g=new Float32Array(1);function w(t,e){let i=e.clientX-t.clientX,n=e.clientY-t.clientY;return Math.sqrt(i*i+n*n)}class y{constructor(t,e={}){this.scene=t,this.canvas=t.viewer.canvas,this.camera=t.camera,this.moveSpeed=e.moveSpeed||2,this.rotationSpeed=e.rotationSpeed||Math.PI/180,this.zoomFactor=e.zoomFactor||.1,this.horizontalAngle=e.horizontalAngle||Math.PI/2,this.verticalAngle=e.verticalAngle||Math.PI/4,this.distance=e.distance||500,this.position=e.position||i(),this.target=e.target||i(),this.twist=e.twist||0,this.mouse={buttons:[!1,!1,!1],x:0,y:0,x2:0,y2:0},this.touchMode=-1,this.touches=[],this.instance=null,this.onManualChange=e.onManualChange||null,this.fov=e.fov||Math.PI/4,this.nearClipPlane=e.nearClipPlane||1,this.farClipPlane=e.farClipPlane||2e5,this.update(),window.addEventListener("resize",(t=>this.onResize())),setTimeout((()=>this.onResize()),0),this.canvas.addEventListener("contextmenu",(t=>t.preventDefault())),this.canvas.addEventListener("selectstart",(t=>t.preventDefault())),this.canvas.addEventListener("mousedown",(t=>{t.preventDefault(),this.mouse.buttons[t.button]=!0})),document.addEventListener("mouseup",(t=>{t.preventDefault(),this.mouse.buttons[t.button]=!1})),window.addEventListener("mousemove",(t=>{this.mouse.x2=this.mouse.x,this.mouse.y2=this.mouse.y,this.mouse.x=t.clientX,this.mouse.y=t.clientY;let e=this.mouse.x-this.mouse.x2,i=this.mouse.y-this.mouse.y2;this.mouse.buttons[0]&&this.rotate(e,i),this.mouse.buttons[2]&&this.move(-e,i)})),this.canvas.addEventListener("wheel",(t=>{t.preventDefault();let e=t.deltaY;1===t.deltaMode&&(e=e/3*100),this.zoom(e/100)})),this.canvas.addEventListener("touchstart",(t=>{t.preventDefault();let e=t.targetTouches;1===e.length?this.touchMode=0:2==e.length?this.touchMode=1:this.touchMode=-1,this.touches.length=0,this.touches.push(...e)})),this.canvas.addEventListener("touchend",(t=>{t.preventDefault(),this.touchMode=-1})),this.canvas.addEventListener("touchcancel",(t=>{t.preventDefault(),this.touchMode=-1})),this.canvas.addEventListener("touchmove",(t=>{t.preventDefault();let e=t.targetTouches;if(0===this.touchMode){let t=this.touches[0],i=e[0],n=i.clientX-t.clientX,r=i.clientY-t.clientY;this.rotate(n,r)}else if(1===this.touchMode){let t=w(this.touches[0],this.touches[1]),i=w(e[0],e[1]);this.zoom((t-i)/50)}this.touches.length=0,this.touches.push(...e)}))}update(){if(this.instance){let t=this.instance,e=t.model.cameras[0];e.getTranslation(A,t.sequence,t.frame,t.counter),a(A,A,e.position),e.getTargetTranslation(m,t.sequence,t.frame,t.counter),a(m,m,e.targetPosition),e.getRotation(g,t.sequence,t.frame,t.counter),this.twist=g[0],l(A,A,t.worldMatrix),l(m,m,t.worldMatrix),this.moveToAndFace(A,m)}else this.updateInternalCamera()}move(t,e){let i=this.camera.directionX,n=this.camera.directionY,r=this.canvas.width,l=this.canvas.height,u=r/l,c=t/r*this.distance*u,d=e/l*this.distance;a(this.target,this.target,o(A,h(A,s(A,i[0],i[1],0)),c)),a(this.target,this.target,o(A,h(A,s(A,n[0],n[1],0)),d)),this.manualChange()}rotate(t,e){this.horizontalAngle-=t*this.rotationSpeed,this.verticalAngle-=e*this.rotationSpeed,this.manualChange()}zoom(t){this.distance=Math.max(1,this.distance*(1+t*this.zoomFactor)),this.manualChange()}manualChange(){this.updateInternalCamera(),this.instance&&(this.instance=null,this.onManualChange&&this.onManualChange())}onResize(){let t=Math.max(this.canvas.clientWidth,1),e=Math.max(this.canvas.clientHeight,1);this.canvas.width=t,this.canvas.height=e,this.scene.viewport[2]=t,this.scene.viewport[3]=e,this.camera.perspective(this.fov,t/e,this.nearClipPlane,this.farClipPlane)}moveToAndFace(t,e){!function(t,e,i){t[0]=e[0]-i[0],t[1]=e[1]-i[1],t[2]=e[2]-i[2]}(A,t,e);let i=n(A),r=Math.atan2(A[1],A[0]),s=Math.acos(A[2]/i);!function(t,e){t[0]=e[0],t[1]=e[1],t[2]=e[2]}(this.target,e),this.verticalAngle=s,this.horizontalAngle=r+Math.PI/2,this.distance=i,this.updateInternalCamera()}updateInternalCamera(){this.verticalAngle=Math.min(Math.max(.01,this.verticalAngle),Math.PI-.01),function(t){t[0]=0,t[1]=0,t[2]=0,t[3]=1}(v),function(t,e,i){i*=.5;var n=e[0],r=e[1],s=e[2],a=e[3],o=Math.sin(i),h=Math.cos(i);t[0]=n*h+r*o,t[1]=r*h-n*o,t[2]=s*h+a*o,t[3]=a*h-s*o}(v,v,this.horizontalAngle),function(t,e,i){i*=.5;var n=e[0],r=e[1],s=e[2],a=e[3],o=Math.sin(i),h=Math.cos(i);t[0]=n*h+a*o,t[1]=r*h+s*o,t[2]=s*h-r*o,t[3]=a*h-n*o}(v,v,this.verticalAngle),s(this.position,0,0,1),function(t,e,i){var n=i[0],r=i[1],s=i[2],a=i[3],o=e[0],h=e[1],l=e[2],u=r*l-s*h,c=s*o-n*l,d=n*h-r*o,f=r*d-s*c,A=s*u-n*d,m=n*c-r*u,v=2*a;u*=v,c*=v,d*=v,f*=2,A*=2,m*=2,t[0]=o+u+f,t[1]=h+c+A,t[2]=l+d+m}(this.position,this.position,v),o(this.position,this.position,this.distance),a(this.position,this.position,this.target);let t=this.twist-Math.PI/2;s(A,0,-Math.cos(t),-Math.sin(t)),this.camera.moveToAndFace(this.position,this.target,A)}applyInstanceCamera(t){this.instance=t,this.fov=t.model.cameras[0].fieldOfView,this.onResize(),this.update()}}const x=new TextDecoder,_=new TextEncoder;function B(t){return x.decode(t)}function b(t){return _.encode(t)}const p=new ArrayBuffer(8),C=new Int8Array(p),T=new Int16Array(p),E=new Int32Array(p),I=new Uint8Array(p),D=new Uint16Array(p),F=new Uint32Array(p),R=new Float32Array(p),L=new Float64Array(p);function S(t){return I[0]=t,C[0]}function U(t,e){return I[0]=t,I[1]=e,T[0]}function M(t,e,i,n){return I[0]=t,I[1]=e,I[2]=i,I[3]=n,E[0]}function P(t,e){return I[0]=t,I[1]=e,D[0]}function N(t,e,i,n){return I[0]=t,I[1]=e,I[2]=i,I[3]=n,F[0]}function $(t,e,i,n){return I[0]=t,I[1]=e,I[2]=i,I[3]=n,R[0]}function O(t,e,i,n,r,s,a,o){return I[0]=t,I[1]=e,I[2]=i,I[3]=n,I[4]=r,I[5]=s,I[6]=a,I[7]=o,L[0]}function G(t){return I[0]=t,C[0]}function H(t,e){return T[0]=e,t[0]=I[0],t[1]=I[1],t}function z(t,e){return E[0]=e,t[0]=I[0],t[1]=I[1],t[2]=I[2],t[3]=I[3],t}function V(t,e){return D[0]=e,t[0]=I[0],t[1]=I[1],t}function Y(t,e){return F[0]=e,t[0]=I[0],t[1]=I[1],t[2]=I[2],t[3]=I[3],t}function W(t,e){return R[0]=e,t[0]=I[0],t[1]=I[1],t[2]=I[2],t[3]=I[3],t}function k(t,e){return L[0]=e,t[0]=I[0],t[1]=I[1],t[2]=I[2],t[3]=I[3],t[4]=I[4],t[5]=I[5],t[6]=I[6],t[7]=I[7],t}const X=new Uint8Array(8);class j{index=0;constructor(t,e,i){const n=function(t){return t instanceof Uint8Array?t:"string"==typeof t?b(t):new Uint8Array(t)}(t);e=e||0,i=i||n.length,this.buffer=t,this.uint8array=n.subarray(e,e+i),this.byteLength=i,this.remaining=i}substream(t){if(this.remaining<t)throw new Error(`ByteStream: substream: want ${t} bytes but have ${this.remaining}`);const e=this.index;return this.index+=t,new j(this.uint8array.subarray(e,e+t))}skip(t){if(this.remaining<t)throw new Error(`ByteStream: skip: premature end - want ${t} bytes but have ${this.remaining}`);this.index+=t,this.remaining-=t}seek(t){this.index=t,this.remaining=this.byteLength-t}read(t){if(this.remaining<t)throw new Error(`ByteStream: read: premature end - want ${t} bytes but have ${this.remaining}`);const e=this.uint8array,i=this.index;let n=function(t,e,i=0,n=1/0){const r=Math.max(i,0),s=Math.min(r+n,t.length);for(let i=r;i<s;i++)if(t[i]===e)return i;return-1}(e,0,i,t);return-1===n&&(n=i+t),this.index+=t,this.remaining-=t,B(e.subarray(i,n))}readNull(){if(this.remaining<1)throw new Error("ByteStream: readNull: premature end - want at least 1 byte but have 0");const t=this.uint8array,e=this.index;let i=t.indexOf(0,e);-1===i&&(i=t.length-1);const n=i-e+1;return this.index+=n,this.remaining-=n,B(t.subarray(e,i))}readBinary(t){if(this.remaining<t)throw new Error(`ByteStream: readBinary: premature end - want ${t} bytes but have ${this.remaining}`);const e=this.uint8array,i=this.index;let n="";for(let r=0;r<t;r++)n+=String.fromCharCode(e[i+r]);return this.index+=t,this.remaining-=t,n}readInt8(){if(this.remaining<1)throw new Error(`ByteStream: readInt8: premature end - want 1 byte but have ${this.remaining}`);const t=this.index,e=S(this.uint8array[t]);return this.index+=1,this.remaining-=1,e}readInt16(){if(this.remaining<2)throw new Error(`ByteStream: readInt16: premature end - want 2 bytes but have ${this.remaining}`);const t=this.index,e=this.uint8array,i=U(e[t],e[t+1]);return this.index+=2,this.remaining-=2,i}readInt32(){if(this.remaining<4)throw new Error(`ByteStream: readInt32: premature end - want 4 bytes but have ${this.remaining}`);const t=this.index,e=this.uint8array,i=M(e[t],e[t+1],e[t+2],e[t+3]);return this.index+=4,this.remaining-=4,i}readUint8(){if(this.remaining<1)throw new Error(`ByteStream: readUint8: premature end - want 1 byte but have ${this.remaining}`);const t=this.uint8array[this.index];return this.index+=1,this.remaining-=1,t}readUint16(){if(this.remaining<2)throw new Error(`ByteStream: readUint16: premature end - want 2 bytes but have ${this.remaining}`);const t=this.index,e=this.uint8array,i=P(e[t],e[t+1]);return this.index+=2,this.remaining-=2,i}readUint32(){if(this.remaining<4)throw new Error(`ByteStream: readUint32: premature end - want 4 bytes but have ${this.remaining}`);const t=this.index,e=this.uint8array,i=N(e[t],e[t+1],e[t+2],e[t+3]);return this.index+=4,this.remaining-=4,i}readFloat32(){if(this.remaining<4)throw new Error(`ByteStream: readFloat32: premature end - want 4 bytes but have ${this.remaining}`);const t=this.index,e=this.uint8array,i=$(e[t],e[t+1],e[t+2],e[t+3]);return this.index+=4,this.remaining-=4,i}readFloat64(){if(this.remaining<8)throw new Error(`ByteStream: readFloat64: premature end - want 8 bytes but have ${this.remaining}`);const t=this.index,e=this.uint8array,i=O(e[t],e[t+1],e[t+2],e[t+3],e[t+4],e[t+5],e[t+6],e[t+7]);return this.index+=8,this.remaining-=8,i}readInt8Array(t){if(ArrayBuffer.isView(t)||(t=new Int8Array(t)),this.remaining<t.byteLength)throw new Error(`ByteStream: readInt8Array: premature end - want ${t.byteLength} bytes but have ${this.remaining}`);const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++)t[n]=S(i[e+n]);return this.index+=t.byteLength,this.remaining-=t.byteLength,t}readInt16Array(t){if(ArrayBuffer.isView(t)||(t=new Int16Array(t)),this.remaining<t.byteLength)throw new Error(`ByteStream: readInt16Array: premature end - want ${t.byteLength} bytes but have ${this.remaining}`);const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+2*n;t[n]=U(i[r],i[r+1])}return this.index+=t.byteLength,this.remaining-=t.byteLength,t}readInt32Array(t){if(ArrayBuffer.isView(t)||(t=new Int32Array(t)),this.remaining<t.byteLength)throw new Error(`ByteStream: readInt32Array: premature end - want ${t.byteLength} bytes but have ${this.remaining}`);const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+4*n;t[n]=M(i[r],i[r+1],i[r+2],i[r+3])}return this.index+=t.byteLength,this.remaining-=t.byteLength,t}readUint8Array(t){if(ArrayBuffer.isView(t)||(t=new Uint8Array(t)),this.remaining<t.byteLength)throw new Error(`ByteStream: readUint8Array: premature end - want ${t.byteLength} bytes but have ${this.remaining}`);const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++)t[n]=i[e+n];return this.index+=t.byteLength,this.remaining-=t.byteLength,t}readUint16Array(t){if(ArrayBuffer.isView(t)||(t=new Uint16Array(t)),this.remaining<t.byteLength)throw new Error(`ByteStream: readUint16Array: premature end - want ${t.byteLength} bytes but have ${this.remaining}`);const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+2*n;t[n]=P(i[r],i[r+1])}return this.index+=t.byteLength,this.remaining-=t.byteLength,t}readUint32Array(t){if(ArrayBuffer.isView(t)||(t=new Uint32Array(t)),this.remaining<t.byteLength)throw new Error(`ByteStream: readUint32Array: premature end - want ${t.byteLength} bytes but have ${this.remaining}`);const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+4*n;t[n]=N(i[r],i[r+1],i[r+2],i[r+3])}return this.index+=t.byteLength,this.remaining-=t.byteLength,t}readFloat32Array(t){if(ArrayBuffer.isView(t)||(t=new Float32Array(t)),this.remaining<t.byteLength)throw new Error(`ByteStream: readFloat32Array: premature end - want ${t.byteLength} bytes but have ${this.remaining}`);const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+4*n;t[n]=$(i[r],i[r+1],i[r+2],i[r+3])}return this.index+=t.byteLength,this.remaining-=t.byteLength,t}readFloat64Array(t){if(ArrayBuffer.isView(t)||(t=new Float64Array(t)),this.remaining<t.byteLength)throw new Error(`ByteStream: readFloat64Array: premature end - want ${t.byteLength} bytes but have ${this.remaining}`);const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+8*n;t[n]=O(i[r],i[r+1],i[r+2],i[r+3],i[r+4],i[r+5],i[r+6],i[r+7])}return this.index+=t.byteLength,this.remaining-=t.byteLength,t}write(t){const e=b(t);return this.writeUint8Array(e),e.length}writeNull(t){const e=this.write(t);return this.index++,this.remaining--,e+1}writeBinary(t){const e=this.index,i=this.uint8array,n=t.length;for(let r=0;r<n;r++)i[e+r]=t.charCodeAt(r);this.index+=n}writeInt8(t){this.uint8array[this.index]=G(t),this.index+=1}writeInt16(t){const e=this.index,i=this.uint8array;H(X,t),i[e]=X[0],i[e+1]=X[1],this.index+=2}writeInt32(t){const e=this.index,i=this.uint8array;z(X,t),i[e]=X[0],i[e+1]=X[1],i[e+2]=X[2],i[e+3]=X[3],this.index+=4}writeUint8(t){this.uint8array[this.index]=t,this.index+=1}writeUint16(t){const e=this.index,i=this.uint8array;V(X,t),i[e]=X[0],i[e+1]=X[1],this.index+=2}writeUint32(t){const e=this.index,i=this.uint8array;Y(X,t),i[e]=X[0],i[e+1]=X[1],i[e+2]=X[2],i[e+3]=X[3],this.index+=4}writeFloat32(t){const e=this.index,i=this.uint8array;W(X,t),i[e]=X[0],i[e+1]=X[1],i[e+2]=X[2],i[e+3]=X[3],this.index+=4}writeFloat64(t){const e=this.index,i=this.uint8array;k(X,t),i[e]=X[0],i[e+1]=X[1],i[e+2]=X[2],i[e+3]=X[3],i[e+4]=X[4],i[e+5]=X[5],i[e+6]=X[6],i[e+7]=X[7],this.index+=8}writeInt8Array(t){const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++)i[e+n]=G(t[n]);this.index+=t.byteLength}writeInt16Array(t){const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+2*n;H(X,t[n]),i[r]=X[0],i[r+1]=X[1]}this.index+=t.byteLength}writeInt32Array(t){const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+4*n;z(X,t[n]),i[r]=X[0],i[r+1]=X[1],i[r+2]=X[2],i[r+3]=X[3]}this.index+=t.byteLength}writeUint8Array(t){const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++)i[e+n]=t[n];this.index+=t.byteLength}writeUint16Array(t){const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+2*n;V(X,t[n]),i[r]=X[0],i[r+1]=X[1]}this.index+=t.byteLength}writeUint32Array(t){const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+4*n;Y(X,t[n]),i[r]=X[0],i[r+1]=X[1],i[r+2]=X[2],i[r+3]=X[3]}this.index+=t.byteLength}writeFloat32Array(t){const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+4*n;W(X,t[n]),i[r]=X[0],i[r+1]=X[1],i[r+2]=X[2],i[r+3]=X[3]}this.index+=t.byteLength}writeFloat64Array(t){const e=this.index,i=this.uint8array;for(let n=0,r=t.length;n<r;n++){const r=e+8*n;k(X,t[n]),i[r]=X[0],i[r+1]=X[1],i[r+2]=X[2],i[r+3]=X[3],i[r+4]=X[4],i[r+5]=X[5],i[r+6]=X[6],i[r+7]=X[7]}this.index+=t.byteLength}}class q{groundHeight=0;waterHeight=0;mapEdge=0;ramp=0;blight=0;water=0;boundary=0;groundTexture=0;cliffVariation=0;groundVariation=0;cliffTexture=0;layerHeight=0;load(t){this.groundHeight=(t.readInt16()-8192)/512;const e=t.readInt16();this.waterHeight=((16383&e)-8192)/512,this.mapEdge=16384&e;const i=t.readUint8();this.ramp=16&i,this.blight=32&i,this.water=64&i,this.boundary=128&i,this.groundTexture=15&i;const n=t.readUint8();this.cliffVariation=(224&n)>>>5,this.groundVariation=31&n;const r=t.readUint8();this.cliffTexture=(240&r)>>>4,this.layerHeight=15&r}save(t){t.writeInt16(512*this.groundHeight+8192),t.writeInt16(512*this.waterHeight+8192+this.mapEdge<<14),t.writeUint8(this.ramp<<4|this.blight<<5|this.water<<6|this.boundary<<7|this.groundTexture),t.writeUint8(this.cliffVariation<<5|this.groundVariation),t.writeUint8((this.cliffTexture<<4)+this.layerHeight)}}class K{version=0;tileset="A";haveCustomTileset=0;groundTilesets=[];cliffTilesets=[];mapSize=new Int32Array(2);centerOffset=new Float32Array(2);corners=[];load(t){const e=new j(t);if("W3E!"===e.readBinary(4)){this.version=e.readInt32(),this.tileset=e.readBinary(1),this.haveCustomTileset=e.readInt32();for(let t=0,i=e.readInt32();t<i;t++)this.groundTilesets[t]=e.readBinary(4);for(let t=0,i=e.readInt32();t<i;t++)this.cliffTilesets[t]=e.readBinary(4);e.readInt32Array(this.mapSize),e.readFloat32Array(this.centerOffset);for(let t=0,i=this.mapSize[1];t<i;t++){this.corners[t]=[];for(let i=0,n=this.mapSize[0];i<n;i++){const n=new q;n.load(e),this.corners[t][i]=n}}}}save(){const t=new j(new ArrayBuffer(this.getByteLength()));t.writeBinary("W3E!"),t.writeInt32(this.version),t.writeBinary(this.tileset),t.writeInt32(this.haveCustomTileset),t.writeUint32(this.groundTilesets.length);for(const e of this.groundTilesets)t.writeBinary(e);t.writeUint32(this.cliffTilesets.length);for(const e of this.cliffTilesets)t.writeBinary(e);t.writeInt32Array(this.mapSize),t.writeFloat32Array(this.centerOffset);for(const e of this.corners)for(const i of e)i.save(t);return t.uint8array}getByteLength(){return 37+4*this.groundTilesets.length+4*this.cliffTilesets.length+this.mapSize[0]*this.mapSize[1]*7}isWater(t,e){const i=this.corners;return i[e][t].water||i[e][t+1].water||i[e+1][t].water||i[e+1][t+1].water}isCliff(t,e){const[i,n]=this.mapSize;if(t<1||t>i-2||e<1||e>n-2)return!1;const r=this.corners,s=r[e][t].layerHeight,a=r[e][t+1].layerHeight,o=r[e+1][t].layerHeight,h=r[e+1][t+1].layerHeight;return s!==a||s!==o||s!==h}cornerTexture(t,e,i,n){const r=this.corners,s=this.mapSize[0]-1,a=this.mapSize[1]-1;for(let o=-1;o<1;o++)for(let h=-1;h<1;h++)if(t+h>0&&t+h<s-1&&e+o>0&&e+o<a-1&&this.isCliff(t+h,e+o)){let s=r[e+o][t+h].cliffTexture;return 15===s&&(s=1),this.cliffGroundIndex(s,i,n)}return r[e][t].groundTexture}cliffGroundIndex(t,e,i){const n=i[t].string("groundTile");for(let t=0,i=e.length;t<i;t++)if(e[t].string("tileID")===n)return t;return 0}}class J{rows=[];load(t){if(!t.startsWith("ID"))throw new Error("WrongMagicNumber");const e=this.rows;let i=0,n=0;for(const r of t.split("\n"))if("B"!==r[0])for(const t of r.split(";")){const r=t[0],s=t.substring(1).trim();let a;"X"===r?i=parseInt(s,10)-1:"Y"===r?n=parseInt(s,10)-1:"K"===r&&(e[n]||(e[n]=[]),a='"'===s[0]?s.slice(1,-1):s,e[n][i]=a)}}save(){const t=this.rows,e=t.length,i=[];let n=0;for(let r=0;r<e;r++){const e=t[r],s=e.length;s>n&&(n=s);let a=!0;for(let t=0;t<s;t++){const n=e[t];if(void 0!==n){let e;e="string"==typeof n?`"${n}"`:"boolean"==typeof n?n?"TRUE":"FALSE":`${n}`,a?(a=!1,i.push(`C;X${t+1};Y${r+1};K${e}`)):i.push(`C;X${t+1};K${e}`)}}}return`ID;P\r\nB;X${n};Y${e}\r\n${i.join("\r\n")}\r\nE`}}class Q{properties=new Map;sections=new Map;load(t){let e=this.properties;const i=this.sections;for(const n of t.split("\r\n"))if(n.length&&!n.startsWith("//")&&!n.startsWith(";")&&!n.startsWith("--")){let t=n.match(/^\[(.+?)\]/);if(t){const n=t[1].trim();e=i.get(n),e||(e=new Map,i.set(n,e))}else if(t=n.match(/^(.+?)=(.*?)$/),t){let i=t[2].trim();'"'===i[0]&&(i=i.slice(1,-1)),e.set(t[1].trim(),i)}}}save(){const t=[];for(const[e,i]of this.properties)t.push(`${e}=${i}`);for(const[e,i]of this.sections){t.push(`[${e}]`);for(const[e,n]of i)t.push(`${e}=${n}`)}return t.join("\r\n")}getSection(t){return this.sections.get(t)}}class Z{map={};set(t,e){"string"!=typeof e&&(e=e.toString()),this.map[t.toLowerCase()]=e}string(t){return this.map[t.toLowerCase()]}number(t){const e=this.string(t);return e?parseFloat(e):0}}class tt{map={};constructor(t){t&&this.load(t)}load(t){if(t.startsWith("ID;")){const e=new J;e.load(t);const i=e.rows,n=i[0],r=this.map;for(let t=1,e=i.length;t<e;t++){const e=i[t];if(e){const t=e[0];if(t&&"_"!==t){r[t]||(r[t]=new Z);const i=r[t];for(let t=0,r=n.length;t<r;t++){let r=n[t];void 0===r&&(r=`column${t}`),i.map[r.toLowerCase()]=e[t]}}}}}else{const e=new Q;e.load(t);const i=e.sections,n=this.map;for(const[t,e]of i.entries()){n[t]||(n[t]=new Z);const i=n[t];for(const[t,n]of e)i.map[t.toLowerCase()]=n}}}getRow(t){return this.map[t]}getProperty(t,e){return this.map[t].map[e]}setRow(t,e){this.map[t]=e}findRow(t,e){for(const i of Object.values(this.map))if(i.string(t)===e)return i}}const et={AAAB:1,AAAC:1,AABA:1,AABB:2,AABC:0,AACA:1,AACB:0,AACC:1,ABAA:1,ABAB:1,ABAC:0,ABBA:2,ABBB:1,ABBC:0,ABCA:0,ABCB:0,ABCC:0,ACAA:1,ACAB:0,ACAC:1,ACBA:0,ACBB:0,ACBC:0,ACCA:1,ACCB:0,ACCC:1,BAAA:1,BAAB:1,BAAC:0,BABA:1,BABB:1,BABC:0,BACA:0,BACB:0,BACC:0,BBAA:1,BBAB:1,BBAC:0,BBBA:1,BBCA:0,BCAA:0,BCAB:0,BCAC:0,BCBA:0,BCCA:0,CAAA:1,CAAB:0,CAAC:1,CABA:0,CABB:0,CABC:0,CACA:1,CACB:0,CACC:1,CBAA:0,CBAB:0,CBAC:0,CBBA:0,CBCA:0,CCAA:1,CCAB:0,CCAC:1,CCBA:0,CCCA:1},it={AAAB:2,AAAC:1,AABA:1,AABB:3,AABC:0,AACA:1,AACB:0,AACC:3,ABAA:1,ABAB:2,ABAC:0,ABBA:3,ABBB:0,ABBC:0,ABCA:0,ABCB:0,ABCC:0,ACAA:1,ACAB:0,ACAC:2,ACBA:0,ACBB:0,ACBC:0,ACCA:3,ACCB:0,ACCC:1,BAAA:1,BAAB:3,BAAC:0,BABA:2,BABB:0,BABC:0,BACA:0,BACB:0,BACC:0,BBAA:3,BBAB:1,BBAC:0,BBBA:1,BBCA:0,BCAA:0,BCAB:0,BCAC:0,BCBA:0,BCCA:0,CAAA:1,CAAB:0,CAAC:3,CABA:0,CABB:0,CABC:0,CACA:2,CACB:0,CACC:1,CBAA:0,CBAB:0,CBAC:0,CBBA:0,CBCA:0,CCAA:3,CCAB:0,CCAC:1,CCBA:0,CCCA:1};function nt(t,e,i){return"Cliffs"===t?Math.min(i,et[e]):Math.min(i,it[e])}const rt="\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n",st=`\n${rt}\n\nuniform sampler2D u_tilesets[15];\n\nvarying vec4 v_tilesets;\nvarying vec2 v_uv[4];\nvarying vec3 v_normal;\n\nconst vec3 lightDirection = normalize(vec3(-0.3, -0.3, 0.25));\n\nvec4 sample(float tileset, vec2 uv) {\n  // 1.0 - 1.0 == 0.0 is not always true.\n  int i = int(tileset - 0.6);\n\n  if (i == 0) {\n    return texture2D(u_tilesets[0], uv);\n  } else if (i == 1) {\n    return texture2D(u_tilesets[1], uv);\n  } else if (i == 2) {\n    return texture2D(u_tilesets[2], uv);\n  } else if (i == 3) {\n    return texture2D(u_tilesets[3], uv);\n  } else if (i == 4) {\n    return texture2D(u_tilesets[4], uv);\n  } else if (i == 5) {\n    return texture2D(u_tilesets[5], uv);\n  } else if (i == 6) {\n    return texture2D(u_tilesets[6], uv);\n  } else if (i == 7) {\n    return texture2D(u_tilesets[7], uv);\n  } else if (i == 8) {\n    return texture2D(u_tilesets[8], uv);\n  } else if (i == 9) {\n    return texture2D(u_tilesets[9], uv);\n  } else if (i == 10) {\n    return texture2D(u_tilesets[10], uv);\n  } else if (i == 11) {\n    return texture2D(u_tilesets[11], uv);\n  } else if (i == 12) {\n    return texture2D(u_tilesets[12], uv);\n  } else if (i == 13) {\n    return texture2D(u_tilesets[13], uv);\n  } else if (i == 14) {\n    return texture2D(u_tilesets[14], uv);\n  }\n}\n\nvec4 blend(vec4 color, float tileset, vec2 uv) {\n  vec4 texel = sample(tileset, uv);\n\n  return mix(color, texel, texel.a);\n}\n\nvoid main() {\n  vec4 color = sample(v_tilesets[0], v_uv[0]);\n\n  if (v_tilesets[1] > 0.5) {\n    color = blend(color, v_tilesets[1], v_uv[1]);\n  }\n\n  if (v_tilesets[2] > 0.5) {\n    color = blend(color, v_tilesets[2], v_uv[2]);\n  }\n\n  if (v_tilesets[3] > 0.5) {\n    color = blend(color, v_tilesets[3], v_uv[3]);\n  }\n\n  //color *= clamp(dot(v_normal, lightDirection) + 0.45, 0.0, 1.0);\n\n  gl_FragColor = vec4(color.rgb, 1.0);\n}\n`,at=`\n// #extension GL_OES_standard_derivatives : enable\n\n${rt}\n\nuniform sampler2D u_texture1;\nuniform sampler2D u_texture2;\n\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying float v_texture;\nvarying vec3 v_position;\n\n// const vec3 lightDirection = normalize(vec3(-0.3, -0.3, 0.25));\n\nvec4 sample(float texture, vec2 uv) {\n  // int(0.0) == 0 is not always true.\n  int i = int(texture + 0.1);\n\n  if (i == 0) {\n    return texture2D(u_texture1, uv);\n  } else {\n    return texture2D(u_texture2, uv);\n  }\n}\n\nvoid main() {\n  vec4 color = sample(v_texture, v_uv);\n\n  // vec3 faceNormal = cross(dFdx(v_position), dFdy(v_position));\n  // vec3 normal = normalize((faceNormal + v_normal) * 0.5);\n\n  // color *= clamp(dot(normal, lightDirection) + 0.45, 0.1, 1.0);\n\n  gl_FragColor = color;\n}\n`,ot=`\n${rt}\n\nuniform sampler2D u_waterTexture;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = texture2D(u_waterTexture, v_uv) * v_color;\n}\n`,ht=ModelViewer.parsers.mdlx.Model;class lt{constructor(t,e,i,n,r){const s=t.viewer.gl,a=t.viewer.webgl,o=a.extensions.ANGLE_instanced_arrays,h=a.extensions.OES_vertex_array_object,l=new ht;l.load(e);const u=l.geosets[0],c=u.vertices,d=u.normals,f=u.uvSets[0],A=u.faces,m=c.byteLength,v=m+d.byteLength;let g=null;const w=r.attribs;h&&(g=h.createVertexArrayOES(),h.bindVertexArrayOES(g));const y=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,y),s.bufferData(s.ARRAY_BUFFER,v+f.byteLength,s.STATIC_DRAW),s.bufferSubData(s.ARRAY_BUFFER,0,c),s.bufferSubData(s.ARRAY_BUFFER,m,d),s.bufferSubData(s.ARRAY_BUFFER,v,f),h&&(s.vertexAttribPointer(w.a_position,3,s.FLOAT,!1,0,0),s.enableVertexAttribArray(w.a_position),s.vertexAttribPointer(w.a_normal,3,s.FLOAT,!1,0,m),s.enableVertexAttribArray(w.a_normal),s.vertexAttribPointer(w.a_uv,2,s.FLOAT,!1,0,v),s.enableVertexAttribArray(w.a_uv));const x=4*i.length,_=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,_),s.bufferData(s.ARRAY_BUFFER,x+n.length,s.STATIC_DRAW),s.bufferSubData(s.ARRAY_BUFFER,0,new Float32Array(i)),s.bufferSubData(s.ARRAY_BUFFER,x,new Uint8Array(n)),h&&(s.vertexAttribPointer(w.a_instancePosition,3,s.FLOAT,!1,0,0),s.enableVertexAttribArray(w.a_instancePosition),o.vertexAttribDivisorANGLE(w.a_instancePosition,1),s.vertexAttribPointer(w.a_instanceTexture,1,s.UNSIGNED_BYTE,!1,0,x),s.enableVertexAttribArray(w.a_instanceTexture),o.vertexAttribDivisorANGLE(w.a_instanceTexture,1));const B=s.createBuffer();s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,B),s.bufferData(s.ELEMENT_ARRAY_BUFFER,A,s.STATIC_DRAW),h&&h.bindVertexArrayOES(null),this.map=t,this.vertexBuffer=y,this.faceBuffer=B,this.normalsOffset=m,this.uvsOffset=v,this.elements=A.length,this.locationAndTextureBuffer=_,this.texturesOffset=x,this.instances=i.length/3,this.vao=g}render(t){const e=this.map.viewer,i=e.gl,n=e.webgl,r=n.extensions.ANGLE_instanced_arrays,s=n.extensions.OES_vertex_array_object,a=t.attribs;s?s.bindVertexArrayOES(this.vao):(i.bindBuffer(i.ARRAY_BUFFER,this.locationAndTextureBuffer),i.vertexAttribPointer(a.a_instancePosition,3,i.FLOAT,!1,0,0),i.vertexAttribPointer(a.a_instanceTexture,1,i.UNSIGNED_BYTE,!1,0,this.texturesOffset),i.bindBuffer(i.ARRAY_BUFFER,this.vertexBuffer),i.vertexAttribPointer(a.a_position,3,i.FLOAT,!1,0,0),i.vertexAttribPointer(a.a_normal,3,i.FLOAT,!1,0,this.normalsOffset),i.vertexAttribPointer(a.a_uv,2,i.FLOAT,!1,0,this.uvsOffset),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,this.faceBuffer)),r.drawElementsInstancedANGLE(i.TRIANGLES,this.elements,i.UNSIGNED_SHORT,0,this.instances),s&&s.bindVertexArrayOES(null)}}class ut{id="\0\0\0\0";chance=0;load(t){this.id=t.readBinary(4),this.chance=t.readInt32()}save(t){t.writeBinary(this.id),t.writeInt32(this.chance)}}class ct{items=[];load(t){for(let e=0,i=t.readUint32();e<i;e++){const e=new ut;e.load(t),this.items.push(e)}}save(t){t.writeUint32(this.items.length);for(const e of this.items)e.save(t)}getByteLength(){return 4+8*this.items.length}}class dt{id="\0\0\0\0";variation=0;location=new Float32Array(3);angle=0;scale=new Float32Array([1,1,1]);skin="\0\0\0\0";flags=0;life=0;itemTable=-1;itemSets=[];editorId=0;u1=new Uint8Array(8);load(t,e,i){if(this.id=t.readBinary(4),this.variation=t.readInt32(),t.readFloat32Array(this.location),this.angle=t.readFloat32(),t.readFloat32Array(this.scale),i>131&&(this.skin=t.readBinary(4)),this.flags=t.readUint8(),this.life=t.readUint8(),e>7){this.itemTable=t.readUint32();for(let e=0,i=t.readUint32();e<i;e++){const e=new ct;e.load(t),this.itemSets.push(e)}}this.editorId=t.readInt32()}save(t,e,i){if(t.writeBinary(this.id),t.writeInt32(this.variation),t.writeFloat32Array(this.location),t.writeFloat32(this.angle),t.writeFloat32Array(this.scale),i>131&&t.writeBinary(this.skin),t.writeUint8(this.flags),t.writeUint8(this.life),e>7){t.writeUint32(this.itemTable),t.writeUint32(this.itemSets.length);for(const e of this.itemSets)e.save(t)}t.writeInt32(this.editorId)}getByteLength(t,e){let i=42;if(e>131&&(i+=4),t>7){i+=8;for(const t of this.itemSets)i+=t.getByteLength()}return i}}class ft{id="\0\0\0\0";u1=0;location=new Uint32Array(2);load(t,e){this.id=t.readBinary(4),this.u1=t.readUint32(),t.readUint32Array(this.location)}save(t,e){t.writeBinary(this.id),t.writeUint32(this.u1),t.writeUint32Array(this.location)}}class At{version=0;u1=new Uint8Array(4);doodads=[];u2=new Uint8Array(4);terrainDoodads=[];load(t,e){const i=new j(t);if("W3do"!==i.readBinary(4))throw new Error("Not a valid war3map.doo buffer");this.version=i.readInt32(),i.readUint8Array(this.u1);for(let t=0,n=i.readInt32();t<n;t++){const t=new dt;t.load(i,this.version,e),this.doodads.push(t)}i.readUint8Array(this.u2);for(let t=0,e=i.readInt32();t<e;t++){const t=new ft;t.load(i,this.version),this.terrainDoodads.push(t)}}save(t){const e=new j(new ArrayBuffer(this.getByteLength(t)));e.writeBinary("W3do"),e.writeInt32(this.version),e.writeUint8Array(this.u1),e.writeUint32(this.doodads.length);for(const i of this.doodads)i.save(e,this.version,t);e.writeUint8Array(this.u2),e.writeUint32(this.terrainDoodads.length);for(const t of this.terrainDoodads)t.save(e,this.version);return e.uint8array}getByteLength(t){let e=24+16*this.terrainDoodads.length;for(const i of this.doodads)e+=i.getByteLength(this.version,t);return e}}r(1,0,0),r(0,1,0);const mt=r(0,0,1);function vt(t,e){return t.sequence.rarity-e.sequence.rarity}let gt;i(),r(1,1,1),function(t,i,n,r){var s=new e(4);s[0]=t,s[1]=i,s[2]=n,s[3]=r}(0,0,0,0),c(),u(),i(),i(),i(),function(t){t[t.IDLE=0]="IDLE",t[t.WALK=1]="WALK"}(gt||(gt={}));class wt{state=gt.IDLE;constructor(t,e){this.instance=e.addInstance(),this.instance.setScene(t.worldScene)}update(){(this.instance.sequenceEnded||-1===this.instance.sequence)&&this.state===gt.IDLE&&function(t){const e=function(t,e){const i=function(t,e){const i=[];for(let t=0,n=e.length;t<n;t++){const n=e[t];"stand"===n.name.split("-")[0].replace(/\d/g,"").trim().toLowerCase()&&i.push({sequence:n,index:t})}return i}(0,e);let n,r;for(i.sort(vt),n=0,r=i.length;n<r;n++){const t=i[n].sequence.rarity;if(0===t)break;if(10*Math.random()>t)return i[n]}const s=i.length-n;return i[n+Math.floor(Math.random()*s)]}(0,t.model.sequences);e&&t.setSequence(e.index)}(this.instance)}}class yt extends wt{constructor(t,e,i,n){super(t,e);const r=this.instance;r.move(n.location),r.rotateLocal(d(c(),mt,n.angle)),r.scale(n.scale),r.setScene(t.worldScene),this.instance=r,this.row=i}}const xt=i();class _t extends wt{constructor(t,e,i,n){super(t,e);const r=this.instance;r.move(n.location),r.rotateLocal(d(c(),mt,n.angle)),r.scale(n.scale),r.setTeamColor(n.player),r.setScene(t.worldScene),i&&(xt[2]=i.number("moveHeight"),r.move(xt),r.setVertexColor([i.number("red")/255,i.number("green")/255,i.number("blue")/255,1]),r.uniformScale(i.number("modelScale"))),this.instance=r,this.row=i}}class Bt{id="\0\0\0\0";chance=0;load(t){this.id=t.readBinary(4),this.chance=t.readInt32()}save(t){t.writeBinary(this.id),t.writeInt32(this.chance)}}class bt{items=[];load(t){for(let e=0,i=t.readInt32();e<i;e++){const i=new Bt;i.load(t),this.items[e]=i}}save(t){t.writeInt32(this.items.length);for(const e of this.items)e.save(t)}getByteLength(){return 4+8*this.items.length}}class pt{slot=0;id="\0\0\0\0";load(t){this.slot=t.readInt32(),this.id=t.readBinary(4)}save(t){t.writeInt32(this.slot),t.writeBinary(this.id)}}class Ct{id="\0\0\0\0";activeForAutocast=0;heroLevel=1;load(t){this.id=t.readBinary(4),this.activeForAutocast=t.readInt32(),this.heroLevel=t.readInt32()}save(t){t.writeBinary(this.id),t.writeInt32(this.activeForAutocast),t.writeInt32(this.heroLevel)}}class Tt{id="\0\0\0\0";chance=0;load(t){this.id=t.readBinary(4),this.chance=t.readInt32()}save(t){t.writeBinary(this.id),t.writeInt32(this.chance)}}class Et{id="\0\0\0\0";variation=0;location=new Float32Array(3);angle=0;scale=new Float32Array([1,1,1]);skin="\0\0\0\0";flags=0;player=0;unknown=0;hitpoints=-1;mana=-1;droppedItemTable=0;droppedItemSets=[];goldAmount=0;targetAcquisition=0;heroLevel=0;heroStrength=0;heroAgility=0;heroIntelligence=0;itemsInInventory=[];modifiedAbilities=[];randomFlag=0;level=new Uint8Array(3);itemClass=0;unitGroup=0;positionInGroup=0;randomUnitTables=[];customTeamColor=0;waygate=0;creationNumber=0;load(t,e,i,n){this.id=t.readBinary(4),this.variation=t.readInt32(),t.readFloat32Array(this.location),this.angle=t.readFloat32(),t.readFloat32Array(this.scale),n>131&&(this.skin=t.readBinary(4)),this.flags=t.readUint8(),this.player=t.readInt32(),this.unknown=t.readUint16(),this.hitpoints=t.readInt32(),this.mana=t.readInt32(),i>10&&(this.droppedItemTable=t.readInt32());for(let e=0,i=t.readInt32();e<i;e++){const i=new bt;i.load(t),this.droppedItemSets[e]=i}this.goldAmount=t.readInt32(),this.targetAcquisition=t.readFloat32(),this.heroLevel=t.readInt32(),i>10&&(this.heroStrength=t.readInt32(),this.heroAgility=t.readInt32(),this.heroIntelligence=t.readInt32());for(let e=0,i=t.readInt32();e<i;e++){const i=new pt;i.load(t),this.itemsInInventory[e]=i}for(let e=0,i=t.readInt32();e<i;e++){const i=new Ct;i.load(t),this.modifiedAbilities[e]=i}if(this.randomFlag=t.readInt32(),0===this.randomFlag)t.readUint8Array(this.level),this.itemClass=t.readUint8();else if(1===this.randomFlag)this.unitGroup=t.readUint32(),this.positionInGroup=t.readUint32();else if(2===this.randomFlag)for(let e=0,i=t.readInt32();e<i;e++){const i=new Tt;i.load(t),this.randomUnitTables[e]=i}this.customTeamColor=t.readInt32(),this.waygate=t.readInt32(),this.creationNumber=t.readInt32()}save(t,e,i,n){t.writeBinary(this.id),t.writeInt32(this.variation),t.writeFloat32Array(this.location),t.writeFloat32(this.angle),t.writeFloat32Array(this.scale),n>131&&t.writeBinary(this.skin),t.writeUint8(this.flags),t.writeInt32(this.player),t.writeUint16(this.unknown),t.writeInt32(this.hitpoints),t.writeInt32(this.mana),i>10&&t.writeInt32(this.droppedItemTable),t.writeInt32(this.droppedItemSets.length);for(const e of this.droppedItemSets)e.save(t);t.writeInt32(this.goldAmount),t.writeFloat32(this.targetAcquisition),t.writeInt32(this.heroLevel),i>10&&(t.writeInt32(this.heroStrength),t.writeInt32(this.heroAgility),t.writeInt32(this.heroIntelligence)),t.writeInt32(this.itemsInInventory.length);for(const e of this.itemsInInventory)e.save(t);t.writeInt32(this.modifiedAbilities.length);for(const e of this.modifiedAbilities)e.save(t);if(t.writeInt32(this.randomFlag),0===this.randomFlag)t.writeUint8Array(this.level),t.writeUint8(this.itemClass);else if(1===this.randomFlag)t.writeUint32(this.unitGroup),t.writeUint32(this.positionInGroup);else if(2===this.randomFlag){t.writeInt32(this.randomUnitTables.length);for(const e of this.randomUnitTables)e.save(t)}t.writeInt32(this.customTeamColor),t.writeInt32(this.waygate),t.writeInt32(this.creationNumber)}getByteLength(t,e,i){let n=91;i>131&&(n+=4),e>10&&(n+=16);for(const t of this.droppedItemSets)n+=t.getByteLength();return n+=8*this.itemsInInventory.length,n+=12*this.modifiedAbilities.length,0===this.randomFlag?n+=4:1===this.randomFlag?n+=8:2===this.randomFlag&&(n+=4+8*this.randomUnitTables.length),n}}class It{version=8;subversion=11;units=[];load(t,e){const i=new j(t);if("W3do"!==i.readBinary(4))throw new Error("Not a valid war3mapUnits.doo buffer");this.version=i.readInt32(),this.subversion=i.readUint32();for(let t=0,n=i.readInt32();t<n;t++){const n=new Et;n.load(i,this.version,this.subversion,e),this.units[t]=n}}save(t){const e=new j(new ArrayBuffer(this.getByteLength(t)));e.writeBinary("W3do"),e.writeInt32(this.version),e.writeUint32(this.subversion),e.writeInt32(this.units.length);for(const i of this.units)i.save(e,this.version,this.subversion,t);return e.uint8array}getByteLength(t){let e=16;for(const i of this.units)e+=i.getByteLength(this.version,this.subversion,t);return e}}class Dt{centerOffset=new Float32Array(2);mapSize=new Int32Array(2);terrainData=new tt;cliffTypesData=new tt;waterData=new tt;doodadsData=new tt;unitsData=new tt;tilesets=[];cliffTilesets=[];tilesetTextures=[];cliffTextures=[];waterTextures=[];maxDeepColor=new Float32Array(4);minDeepColor=new Float32Array(4);maxShallowColor=new Float32Array(4);minShallowColor=new Float32Array(4);vertexBuffer=null;faceBuffer=null;instanceBuffer=null;textureBuffer=null;variationBuffer=null;waterBuffer=null;heightMap=null;waterHeightMap=null;cliffHeightMap=null;waterIndex=0;doodads=[];units=[];constructor(t,e,i){this.viewer=t,this.worldScene=e,this.groundShader=this.viewer.webgl.createShader("\nuniform mat4 u_VP;\nuniform sampler2D u_heightMap;\nuniform vec2 u_size;\nuniform vec2 u_offset;\nuniform bool u_extended[14];\nuniform float u_baseTileset;\n\nattribute vec2 a_position;\nattribute float a_InstanceID;\nattribute vec4 a_textures;\nattribute vec4 a_variations;\n\nvarying vec4 v_tilesets;\nvarying vec2 v_uv[4];\nvarying vec3 v_normal;\n\nvec2 getCell(float variation) {\n  if (variation < 16.0) {\n    return vec2(mod(variation, 4.0), floor(variation / 4.0));\n  } else {\n    variation -= 16.0;\n\n    return vec2(4.0 + mod(variation, 4.0), floor(variation / 4.0));\n  }\n}\n\nvec2 getUV(vec2 position, bool extended, float variation) {\n  vec2 cell = getCell(variation);\n  vec2 cellSize = vec2(extended ? 0.125 : 0.25, 0.25);\n  vec2 uv = vec2(position.x, 1.0 - position.y);\n  vec2 pixelSize = vec2(1.0 / 512.0, 1.0 / 256.0); /// Note: hardcoded to 512x256 for now.\n\n  return clamp((cell + uv) * cellSize, cell * cellSize + pixelSize, (cell + 1.0) * cellSize - pixelSize); \n}\n\nvoid main() {\n  vec4 textures = a_textures - u_baseTileset;\n  \n  if (textures[0] > 0.0 || textures[1] > 0.0 || textures[2] > 0.0 || textures[3] > 0.0) {\n    v_tilesets = textures;\n\n    v_uv[0] = getUV(a_position, u_extended[int(textures[0]) - 1], a_variations[0]);\n    v_uv[1] = getUV(a_position, u_extended[int(textures[1]) - 1], a_variations[1]);\n    v_uv[2] = getUV(a_position, u_extended[int(textures[2]) - 1], a_variations[2]);\n    v_uv[3] = getUV(a_position, u_extended[int(textures[3]) - 1], a_variations[3]);\n\n    vec2 corner = vec2(mod(a_InstanceID, u_size.x), floor(a_InstanceID / u_size.x));\n    vec2 base = corner + a_position;\n    float height = texture2D(u_heightMap, base / u_size).a;\n\n    float hL = texture2D(u_heightMap, vec2(base - vec2(1.0, 0.0)) / (u_size)).a;\n    float hR = texture2D(u_heightMap, vec2(base + vec2(1.0, 0.0)) / (u_size)).a;\n    float hD = texture2D(u_heightMap, vec2(base - vec2(0.0, 1.0)) / (u_size)).a;\n    float hU = texture2D(u_heightMap, vec2(base + vec2(0.0, 1.0)) / (u_size)).a;\n\n    v_normal = normalize(vec3(hL - hR, hD - hU, 2.0));\n\n    gl_Position = u_VP * vec4(base * 128.0 + u_offset, height * 128.0, 1.0);\n  } else {\n    v_tilesets = vec4(0.0);\n\n    v_uv[0] = vec2(0.0);\n    v_uv[1] = vec2(0.0);\n    v_uv[2] = vec2(0.0);\n    v_uv[3] = vec2(0.0);\n\n    v_normal = vec3(0.0);\n\n    gl_Position = vec4(0.0);\n  }\n}\n",st),this.cliffShader=this.viewer.webgl.createShader("\nuniform mat4 u_VP;\nuniform sampler2D u_heightMap;\nuniform vec2 u_pixel;\nuniform vec2 u_centerOffset;\n\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_uv;\nattribute vec3 a_instancePosition;\nattribute float a_instanceTexture;\n\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying float v_texture;\nvarying vec3 v_position;\n\nvoid main() {\n  // Half of a pixel in the cliff height map.\n  vec2 halfPixel = u_pixel * 0.5;\n\n  // The bottom left corner of the map tile this vertex is on.\n  vec2 corner = floor((a_instancePosition.xy - vec2(1.0, 0.0) - u_centerOffset.xy) / 128.0);\n\n  // Get the 4 closest heights in the height map.\n  float bottomLeft = texture2D(u_heightMap, corner * u_pixel + halfPixel).a;\n  float bottomRight = texture2D(u_heightMap, (corner + vec2(1.0, 0.0)) * u_pixel + halfPixel).a;\n  float topLeft = texture2D(u_heightMap, (corner + vec2(0.0, 1.0)) * u_pixel + halfPixel).a;\n  float topRight = texture2D(u_heightMap, (corner + vec2(1.0, 1.0)) * u_pixel + halfPixel).a;\n  \n  // Do a bilinear interpolation between the heights to get the final value.\n  float bottom = mix(bottomRight, bottomLeft, -a_position.x / 128.0);\n  float top = mix(topRight, topLeft, -a_position.x / 128.0);\n  float height = mix(bottom, top, a_position.y / 128.0);\n\n  v_normal = a_normal;\n  v_uv = a_uv;\n  v_texture = a_instanceTexture;\n  v_position = a_position + vec3(a_instancePosition.xy, a_instancePosition.z + height * 128.0);\n\n  gl_Position = u_VP * vec4(v_position, 1.0);\n}\n",at),this.waterShader=this.viewer.webgl.createShader("\nuniform mat4 u_VP;\nuniform sampler2D u_heightMap;\nuniform sampler2D u_waterHeightMap;\nuniform vec2 u_size;\nuniform vec2 u_offset;\nuniform float u_offsetHeight;\nuniform vec4 u_minDeepColor;\nuniform vec4 u_maxDeepColor;\nuniform vec4 u_minShallowColor;\nuniform vec4 u_maxShallowColor;\n\nattribute vec2 a_position;\nattribute float a_InstanceID;\nattribute float a_isWater;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nconst float minDepth = 10.0 / 128.0;\nconst float deepLevel = 64.0 / 128.0;\nconst float maxDepth = 72.0 / 128.0;\n\nvoid main() {\n  if (a_isWater > 0.5) {\n    v_uv = a_position;\n\n    vec2 corner = vec2(mod(a_InstanceID, u_size.x), floor(a_InstanceID / u_size.x));\n    vec2 base = corner + a_position;\n    float height = texture2D(u_heightMap, base / u_size).a;\n    float waterHeight = texture2D(u_waterHeightMap, base / u_size).a + u_offsetHeight;\n    float value = clamp(waterHeight - height, 0.0, 1.0);\n\n    if (value <= deepLevel) {\n      value = max(0.0, value - minDepth) / (deepLevel - minDepth);\n      v_color = mix(u_minShallowColor, u_maxShallowColor, value) / 255.0;\n    } else {\n      value = clamp(value - deepLevel, 0.0, maxDepth - deepLevel) / (maxDepth - deepLevel);\n      v_color = mix(u_minDeepColor, u_maxDeepColor, value) / 255.0;\n    }\n\n    gl_Position = u_VP * vec4(base * 128.0 + u_offset, waterHeight * 128.0, 1.0);\n  } else {\n    v_uv = vec2(0.0);\n    v_color = vec4(0.0);\n\n    gl_Position = vec4(0.0);\n  }\n}\n",ot),this.w3e=new K,this.w3e.load(i),this.loadBaseFiles().then((()=>{this.loadTerrainCliffsAndWater(),this.loadDoodadsAndDestructibles(),this.loadUnitsAndItems()}))}async loadBaseFile(t,e){return"text"===e?await message.loadTextArray(t):await message.loadBlp(t)}async loadBaseFiles(){const t=[this.loadBaseFile("TerrainArt\\Terrain.slk","text"),this.loadBaseFile("TerrainArt\\CliffTypes.slk","text"),this.loadBaseFile("TerrainArt\\Water.slk","text"),this.loadBaseFile("Doodads\\Doodads.slk","text"),this.loadBaseFile("Doodads\\DoodadMetaData.slk","text"),this.loadBaseFile("Units\\DestructableData.slk","text"),this.loadBaseFile("Units\\DestructableMetaData.slk","text"),this.loadBaseFile("Units\\UnitData.slk","text"),this.loadBaseFile("Units\\unitUI.slk","text"),this.loadBaseFile("Units\\ItemData.slk","text"),this.loadBaseFile("Units\\UnitMetaData.slk","text"),this.loadBaseFile("table\\unit.ini","text")],[e,i,n,r,s,a,o,h,l,u,c,d]=await Promise.all(t);if(!(e&&i&&n&&r&&s&&a&&o&&h&&l&&u&&c))throw new Error("Failed to load the base files");this.terrainData.load(e.join("\n")),this.cliffTypesData.load(i.join("\n")),this.waterData.load(n.join("\n")),this.doodadsData.load(r.join("\n")),this.doodadsData.load(a.join("\n")),this.unitsData.load(h.join("\n")),this.unitsData.load(l.join("\n")),this.unitsData.load(u.join("\n")),this.unitsData.load(d.join("\n"))}async loadTerrainCliffsAndWater(){this.viewer;const t=this.w3e.centerOffset,e=this.w3e.mapSize;this.corners=this.w3e.corners,this.centerOffset.set(t),this.mapSize.set(e),this.worldScene.grid=new this.worldScene.grid.constructor(t[0],t[1],128*e[0]-128,128*e[1]-128,2048,2048);const i=this.w3e.tileset,n=[],r=[],s=[];for(const t of this.w3e.groundTilesets){const e=this.terrainData.getRow(t);this.tilesets.push(e),n.push(this.viewer.load(`${e.string("dir")}\\${e.string("file")}.blp`))}this.blightTextureIndex=n.length,n.push(this.viewer.load(`TerrainArt\\Blight\\${{A:"Ashen",B:"Barrens",C:"Felwood",D:"Cave",F:"Lordf",G:"Dungeon",I:"Ice",J:"DRuins",K:"Citadel",L:"Lords",N:"North",O:"Outland",Q:"VillageFall",V:"Village",W:"Lordw",X:"Village",Y:"Village",Z:"Ruins"}[i]}_Blight.blp`));for(const t of this.w3e.cliffTilesets){const e=this.cliffTypesData.getRow(t);this.cliffTilesets.push(e),r.push(this.viewer.load(`${e.string("texDir")}\\${e.string("texFile")}.blp`))}const a=this.waterData.getRow(`${i}Sha`);this.waterHeightOffset=a.number("height"),this.waterIncreasePerFrame=a.number("texRate")/60,this.waterTextures.length=0,this.maxDeepColor.set([a.number("Dmax_R"),a.number("Dmax_G"),a.number("Dmax_B"),a.number("Dmax_A")]),this.minDeepColor.set([a.number("Dmin_R"),a.number("Dmin_G"),a.number("Dmin_B"),a.number("Dmin_A")]),this.maxShallowColor.set([a.number("Smax_R"),a.number("Smax_G"),a.number("Smax_B"),a.number("Smax_A")]),this.minShallowColor.set([a.number("Smin_R"),a.number("Smin_G"),a.number("Smin_B"),a.number("Smin_A")]);for(let t=0,e=a.number("numTex");t<e;t++)s.push(this.viewer.load(`${a.string("texFile")}${t<10?"0":""}${t}.blp`));this.tilesetTextures=await Promise.all(n),this.cliffTextures=await Promise.all(r),this.waterTextures=await Promise.all(s);const o=this.w3e.corners,[h,l]=this.mapSize,u=(h-1)*(l-1),c=new Float32Array(h*l),d=new Float32Array(h*l),f=new Float32Array(h*l),A=new Uint8Array(4*u),m=new Uint8Array(4*u),v=new Uint8Array(u);let g=0;const w={};this.columns=h-1,this.rows=l-1;for(let e=0;e<l;e++)for(let i=0;i<h;i++){const n=o[e][i],r=e*h+i;if(c[r]=n.groundHeight,d[r]=n.groundHeight+n.layerHeight-2,f[r]=n.waterHeight,e<l-1&&i<h-1){if(v[g]=this.w3e.isWater(i,e),this.w3e.isCliff(i,e)){const r=n.layerHeight,s=o[e][i+1].layerHeight,a=o[e+1][i].layerHeight,h=o[e+1][i+1].layerHeight,l=Math.min(r,s,a,h),u=this.cliffFileName(r,s,a,h,l);if("AAAA"!==u){let r=n.cliffTexture;15===r&&(r=1);const s=this.cliffTilesets[r].string("cliffModelDir"),a=`Doodads\\Terrain\\${s}\\${s}${u}${nt(s,u,n.cliffVariation)}.mdx`;w[a]||(w[a]={locations:[],textures:[]}),w[a].locations.push(128*(i+1)+t[0],128*e+t[1],128*(l-2)),w[a].textures.push(r)}}else{const t=this.w3e.cornerTexture(i,e,this.tilesets,this.cliffTilesets),r=this.w3e.cornerTexture(i+1,e,this.tilesets,this.cliffTilesets),s=this.w3e.cornerTexture(i,e+1,this.tilesets,this.cliffTilesets),a=this.w3e.cornerTexture(i+1,e+1,this.tilesets,this.cliffTilesets),o=(y=[t,r,s,a],y.reverse().filter(((t,e,i)=>-1===i.indexOf(t,e+1))).reverse()).sort();let h=o[0];A[4*g]=h+1,m[4*g]=this.getVariation(h,n.groundVariation),o.shift();for(let e=0,i=o.length;e<i;e++){let i=0;h=o[e],r===h&&(i|=1),t===h&&(i|=2),a===h&&(i|=4),s===h&&(i|=8),A[4*g+1+e]=h+1,m[4*g+1+e]=i}}g+=1}}var y;const x=this.viewer.gl,_=this.viewer.webgl;this.vertexBuffer=x.createBuffer(),x.bindBuffer(x.ARRAY_BUFFER,this.vertexBuffer),x.bufferData(x.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,1,1]),x.STATIC_DRAW),this.faceBuffer=x.createBuffer(),x.bindBuffer(x.ELEMENT_ARRAY_BUFFER,this.faceBuffer),x.bufferData(x.ELEMENT_ARRAY_BUFFER,new Uint8Array([0,1,2,1,3,2]),x.STATIC_DRAW),this.cliffHeightMap=x.createTexture(),x.bindTexture(x.TEXTURE_2D,this.cliffHeightMap),_.setTextureMode(x.CLAMP_TO_EDGE,x.CLAMP_TO_EDGE,x.NEAREST,x.NEAREST),x.texImage2D(x.TEXTURE_2D,0,x.ALPHA,h,l,0,x.ALPHA,x.FLOAT,c),this.heightMap=x.createTexture(),x.bindTexture(x.TEXTURE_2D,this.heightMap),_.setTextureMode(x.CLAMP_TO_EDGE,x.CLAMP_TO_EDGE,x.NEAREST,x.NEAREST),x.texImage2D(x.TEXTURE_2D,0,x.ALPHA,h,l,0,x.ALPHA,x.FLOAT,d),this.waterHeightMap=x.createTexture(),x.bindTexture(x.TEXTURE_2D,this.waterHeightMap),_.setTextureMode(x.CLAMP_TO_EDGE,x.CLAMP_TO_EDGE,x.NEAREST,x.NEAREST),x.texImage2D(x.TEXTURE_2D,0,x.ALPHA,h,l,0,x.ALPHA,x.FLOAT,f),this.instanceBuffer=x.createBuffer(),x.bindBuffer(x.ARRAY_BUFFER,this.instanceBuffer),x.bufferData(x.ARRAY_BUFFER,new Float32Array(u).map(((t,e)=>e)),x.STATIC_DRAW),this.textureBuffer=x.createBuffer(),x.bindBuffer(x.ARRAY_BUFFER,this.textureBuffer),x.bufferData(x.ARRAY_BUFFER,A,x.STATIC_DRAW),this.variationBuffer=x.createBuffer(),x.bindBuffer(x.ARRAY_BUFFER,this.variationBuffer),x.bufferData(x.ARRAY_BUFFER,m,x.STATIC_DRAW),this.waterBuffer=x.createBuffer(),x.bindBuffer(x.ARRAY_BUFFER,this.waterBuffer),x.bufferData(x.ARRAY_BUFFER,v,x.STATIC_DRAW),this.terrainReady=!0,this.anyReady=!0;const B=this.cliffShader,b=Object.entries(w).map((async t=>{const e=t[0],{locations:i,textures:n}=t[1],r=await this.loadBaseFile(e,"arrayBuffer");if(r)return new lt(this,r,i,n,B)})).filter((t=>t));this.cliffModels=await Promise.all(b),this.cliffsReady=!0}async loadDoodadsAndDestructibles(){const t=await message.loadBlp("war3map.doo"),e=new At;try{e.load(t,0)}catch(t){return void console.warn(`Failed to load war3map.doo: ${t}`)}for(const t of e.doodads)try{const e=this.doodadsData.getRow(t.id);if(e){let i=e.string("file");if(i){const n=e.number("numVar");i.endsWith(".mdl")&&(i=i.slice(0,-4));let r=i;i+=".mdx",n>1&&(r+=Math.min(t.variation,n-1)),r+=".mdx",this.viewer.load(r).then((i=>{i&&this.doodads.push(new yt(this,i,e,t))}))}else console.log("Unknown doodad ID",t.id,t)}}catch(e){console.warn(`Failed to load doodad/destructible ID ${t.id}: ${e}`)}}async loadUnitsAndItems(){const t=await message.loadBlp("war3mapUnits.doo"),e=new It;try{e.load(t,0)}catch(t){return void console.warn(`Failed to load war3mapUnits.doo: ${t}`)}for(const t of e.units)try{let e,i;"sloc"===t.id?i="Objects\\StartLocation\\StartLocation.mdx":(e=this.unitsData.getRow(t.id),e&&(i=e.string("file"),i&&(i.endsWith(".mdl")&&(i=i.slice(0,-4)),i+=".mdx"))),i?this.viewer.load(i).then((i=>{if(!i)return this.viewer.load("units/critters/sammycube/sammycube.mdx").then((i=>{i&&this.units.push(new _t(this,i,e,t))}));this.units.push(new _t(this,i,e,t))})):console.log("Unknown unit ID",t.id,t)}catch(e){console.warn(`Failed to load unit/item ID ${t.id}: ${e}`)}this.unitsReady=!0,this.anyReady=!0}getVariation(t,e){const i=this.tilesetTextures[t];return i.width>i.height?e<16?16+e:16===e?15:0:0===e?0:15}cliffFileName(t,e,i,n,r){return String.fromCharCode(65+t-r)+String.fromCharCode(65+i-r)+String.fromCharCode(65+n-r)+String.fromCharCode(65+e-r)}update(){if(this.anyReady){this.viewer.update(),this.waterIndex+=this.waterIncreasePerFrame,this.waterIndex>=this.waterTextures.length&&(this.waterIndex=0);for(const t of this.doodads)t.update();for(const t of this.units)t.update()}}render(){if(this.anyReady){const t=this.worldScene;t.startFrame(),this.renderGround(),this.renderCliffs(),t.renderOpaque(),this.renderWater(),t.renderTranslucent(),this.update()}}renderGround(){if(this.terrainReady){const t=this.viewer.gl,e=this.viewer.webgl,i=e.extensions.ANGLE_instanced_arrays,n=this.groundShader,r=n.uniforms,s=n.attribs,a=this.tilesetTextures,o=s.a_InstanceID,h=s.a_position,l=s.a_textures,u=s.a_variations,c=a.length;t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),e.useShader(n),t.uniformMatrix4fv(r.u_VP,!1,this.worldScene.camera.viewProjectionMatrix),t.uniform2fv(r.u_offset,this.centerOffset),t.uniform2f(r.u_size,this.columns,this.rows),t.uniform1i(r.u_heightMap,15),t.activeTexture(t.TEXTURE15),t.bindTexture(t.TEXTURE_2D,this.heightMap),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.vertexAttribPointer(h,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.instanceBuffer),t.vertexAttribPointer(o,1,t.FLOAT,!1,0,0),i.vertexAttribDivisorANGLE(o,1),t.bindBuffer(t.ARRAY_BUFFER,this.textureBuffer),t.vertexAttribPointer(l,4,t.UNSIGNED_BYTE,!1,0,0),i.vertexAttribDivisorANGLE(l,1),t.bindBuffer(t.ARRAY_BUFFER,this.variationBuffer),t.vertexAttribPointer(u,4,t.UNSIGNED_BYTE,!1,0,0),i.vertexAttribDivisorANGLE(u,1),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.faceBuffer),t.uniform1f(r.u_baseTileset,0);for(let i=0,n=Math.min(c,15);i<n;i++){const n=a[i].width>a[i].height?1:0;t.uniform1f(r[`u_extended[${i}]`],n),t.uniform1i(r[`u_tilesets[${i}]`],i),e.bindTexture(a[i],i)}if(i.drawElementsInstancedANGLE(t.TRIANGLES,6,t.UNSIGNED_BYTE,0,this.rows*this.columns),c>15){t.uniform1f(r.u_baseTileset,15);for(let i=0,n=c-15;i<n;i++){const n=a[i+15].width>a[i+15].height?1:0;t.uniform1f(r[`u_extended[${i}]`],n),e.bindTexture(a[i+15],i)}i.drawElementsInstancedANGLE(t.TRIANGLES,6,t.UNSIGNED_BYTE,0,this.rows*this.columns)}i.vertexAttribDivisorANGLE(l,0),i.vertexAttribDivisorANGLE(u,0),i.vertexAttribDivisorANGLE(o,0)}}renderCliffs(){if(this.cliffsReady){const t=this.viewer.gl,e=this.viewer.webgl,i=e.extensions.ANGLE_instanced_arrays,n=e.extensions.OES_vertex_array_object,r=this.cliffShader,s=r.attribs,a=r.uniforms;t.disable(t.BLEND),r.use(),t.uniformMatrix4fv(a.u_VP,!1,this.worldScene.camera.viewProjectionMatrix),t.uniform1i(a.u_heightMap,0),t.uniform2f(a.u_pixel,1/(this.columns+1),1/(this.rows+1)),t.uniform2fv(a.u_centerOffset,this.centerOffset),t.uniform1i(a.u_texture1,1),t.uniform1i(a.u_texture2,2),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.cliffHeightMap),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,this.cliffTextures[0].webglResource),this.cliffTextures.length>1&&(t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,this.cliffTextures[1].webglResource)),n||(i.vertexAttribDivisorANGLE(s.a_instancePosition,1),i.vertexAttribDivisorANGLE(s.a_instanceTexture,1));for(const t of this.cliffModels)t.render(r);n||(i.vertexAttribDivisorANGLE(s.a_instancePosition,0),i.vertexAttribDivisorANGLE(s.a_instanceTexture,0))}}renderWater(){if(this.terrainReady){const t=this.viewer.gl,e=this.viewer.webgl,i=e.extensions.ANGLE_instanced_arrays,n=this.waterShader,r=n.uniforms,s=n.attribs,a=s.a_InstanceID,o=s.a_position,h=s.a_isWater;t.depthMask(!1),t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),e.useShader(n),t.uniformMatrix4fv(r.u_VP,!1,this.worldScene.camera.viewProjectionMatrix),t.uniform2fv(r.u_offset,this.centerOffset),t.uniform2f(r.u_size,this.columns,this.rows),t.uniform1i(r.u_heightMap,0),t.uniform1i(r.u_waterHeightMap,1),t.uniform1i(r.u_waterTexture,2),t.uniform1f(r.u_offsetHeight,this.waterHeightOffset),t.uniform4fv(r.u_maxDeepColor,this.maxDeepColor),t.uniform4fv(r.u_minDeepColor,this.minDeepColor),t.uniform4fv(r.u_maxShallowColor,this.maxShallowColor),t.uniform4fv(r.u_minShallowColor,this.minShallowColor),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.heightMap),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,this.waterHeightMap),e.bindTexture(this.waterTextures[0|this.waterIndex],2),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.vertexAttribPointer(o,2,t.FLOAT,!1,8,0),t.bindBuffer(t.ARRAY_BUFFER,this.instanceBuffer),t.vertexAttribPointer(a,1,t.FLOAT,!1,4,0),i.vertexAttribDivisorANGLE(a,1),t.bindBuffer(t.ARRAY_BUFFER,this.waterBuffer),t.vertexAttribPointer(h,1,t.UNSIGNED_BYTE,!1,1,0),i.vertexAttribDivisorANGLE(h,1),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.faceBuffer),i.drawElementsInstancedANGLE(t.TRIANGLES,6,t.UNSIGNED_BYTE,0,this.rows*this.columns),i.vertexAttribDivisorANGLE(h,0),i.vertexAttribDivisorANGLE(a,0)}}}const Ft=ModelViewer.viewer.handlers,Rt=ModelViewer.common.glMatrix;Rt.vec3,Rt.quat;let Lt=document.getElementById("canvas");Lt.width=800,Lt.height=600;let St=new ModelViewer.viewer.ModelViewer(Lt);St.debugRenderMode=ModelViewer.viewer.DebugRenderMode.None;let Ut=St.addScene();!function(t,e={}){new y(t,e)}(Ut),St.on("loadstart",(t=>console.log(t))),St.on("load",(t=>console.log("load",t))),St.on("loadend",(t=>console.log("loadend",t))),St.on("error",(t=>console.log("error",t))),St.addHandler(Ft.mdx),St.addHandler(Ft.blp),St.addHandler(Ft.dds),St.addHandler(Ft.tga),document.querySelector(".controls").remove(),window.fetch=async function(t){const e=await message.loadResource(t);if(!e){const e=await message.loadBlp(t);return{ok:!0,arrayBuffer:()=>e}}return{ok:!0,arrayBuffer:()=>e}},message.load().then((({buf:t,ext:e})=>{const i=new Dt(St,Ut,t);requestAnimationFrame((function t(e){requestAnimationFrame(t),i.render()}))})),module.exports=t})();